- aspectos relevantes da implementação dessa arquitectura realçando os pontos fortes e fracos da solução -





Um ponto importante é como realizámos as listas de peers (proxys) nas outras instâncias. Escolhemos um dicionário de int para IPeer/ISuperPeer pois é criada uma nova proxy quando se passa uma entidade MarshalByRef por parâmetro pelo que não é possivel comparar esta proxy com os armazenados numa lista atravez do método contains. Deste modo criámos um Id em cada instância utilizando Datetime.Now.Ticks.GetHashCode(), para que a probabilidade de haver um Id igual em entidades diferentes seja o mais baixo possivel, e utilizamos este Id como Key do proxy no dicionário. Este método de armazenamento também facilita a remoção de proxys cujas conexções estão fechadas. Ao iterar por uma lista não nos é possivel remover um elemento dessa lista no momento da iteração, ao conter um dicionário podemos armazenar as key's para remoção após a iteração.

Uma grande preocupação nossa foi a tolerância a falhas. Estas ocorrem maioritariamente por conexões mal terminadas (peers/superpeers terminados sem desregistarem), pelo que sempre que acedemos a uma proxy, seja no getPeers ou no getArticle, verificamos se a conexção com o peer em questão ainda se encontra activa, em caso negativo removemo-lo da lista.
Uma grande falha seria um pedido de getArticle ou getPeers ficar preso em deadlock ou um loop infinito. Para tratar estas situações colocámos um parâmetro booleano no método getArticle que indica se o método chama getPeers ou apenas verifica nos seus artigos e nos dos peers que consegue contactar directamente. Deste modo, a instância que está à procura de um artigo procura em si, nos peers que consegue contactar directamente e, caso ainda nao tenha encontrado o artigo, nos peers retornados pelo método GetPeers do(s) SuperPeer(s) a que está conectado, mas estes apenas procuram em si e nos directamente asseciveis.
O método getPeers recebe dois parâmetros, um indica o Id da instância que chamou o getPeers para que este não seja testado se está "vivo" pois ocorre um deadlock visto o método ser sincrono, o outro parâmetro é um contexto de pedido. Este contexto é criado no método getArticle e indica o número de saltos possiveis (default = 5) e contém uma lista de id's que indentifica os SuperPeers a quem já foi chamado o método getPeers. O objecto é Serializable para que o valor de saltos seja copiada para cada "nível" de SuperPeers e a lista em si encontra-se envolvida por um objecto MarshalByRef para que seja partilhada entre todas as instâncias. Assim temos a garantia que o pedido não vai passar por um SuperPeer mais do que uma vez e que não passa o número de "níveis" especificado pelo número de saltos.

Também para tentar evitar alguns erros, a nossa aplicação que utiliza windows forms realiza o desregisto do peer/superpeer quando é terminada, mesmo que não seja especificado pelo utilizador.

Um ponto fraco na nossa arquitectura é o método getPeer estar a chamar o método respectivo nos SuperPeers a que se encontra conectado, sincronamente. Isto causa um tempo de espera maior além de ser um caso onde se podia chamar o método asyncronamente em todos os SuperPeers e esperar que todos respondessem. Não foi concretizada a solução descrita devido ao acréscimo de complexidade ao método em si além de não ser um dos objectivos do trabalho, embora seja um ponto que gostariamos de melhorar.

Tivémos também alguns problemas na actualização da UI para informação sobre métodos chamados por outros Peers, visto a actualização de ui ter de ser realizada na thread de criação da ui. Para resolver este caso temos dois passos. Primeiro utilizamos um evento que despoletamos na chamada aos métodos, este utiliza depois um BackgroundWorker para que a actualização seja feita na thread correcta.